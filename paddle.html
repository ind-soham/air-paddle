<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Paddle: Hand Tracker</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; background: #050505; overflow: hidden; font-family: 'Orbitron', sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; }
        
        #game-wrapper { position: relative; width: 100%; max-width: 900px; aspect-ratio: 16/9; border: 2px solid #00f3ff; border-radius: 12px; overflow: hidden; background: #000; box-shadow: 0 0 40px rgba(0, 243, 255, 0.2); }
        
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; }
        /* Mirror the canvas so moving Right moves Right */
        #output_canvas { transform: scaleX(-1); z-index: 2; } 

        .hud { position: absolute; top: 20px; left: 20px; z-index: 10; color: #00f3ff; font-size: 20px; text-shadow: 0 0 10px #00f3ff; pointer-events: none; width: 90%; display: flex; justify-content: space-between;}
        
        #loading { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 20; display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; }
        .spinner { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #00f3ff; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;}
        @keyframes spin { 0% {transform: rotate(0deg);} 100% {transform: rotate(360deg);} }

        .status-searching { color: #ff0055; animation: blink 1s infinite; }
        .status-locked { color: #00ff00; }
        @keyframes blink { 50% { opacity: 0.5; } }
    </style>
</head>
<body>

<div id="game-wrapper">
    <div class="hud">
        <div>SCORE: <span id="score">0</span></div>
        <div id="status-text" class="status-searching">STATUS: SEARCHING...</div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        <h2>INITIALIZING SENSORS...</h2>
        <p>Please allow camera access</p>
    </div>

    <video id="input_video" style="display:none" playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const ctx = canvasElement.getContext('2d');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status-text');
    const loadingScreen = document.getElementById('loading');

    let paddleX = 0.5; // 0.0 to 1.0 (Screen width)
    let ball = { x: 0.5, y: 0.1, vx: 0.005, vy: 0.005, r: 0.02 }; // Normalized coordinates
    let score = 0;
    let gameActive = false;
    let handDetected = false;

    // --- DRAWING FUNCTIONS ---

    function drawDrone(x, y, w, h) {
        let width = w * 0.15; // Paddle width relative to screen
        let height = 20;

        // Draw Target Box around hand position
        if (handDetected) {
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2;
            ctx.strokeRect(x - width/2, y - 40, width, 40);
            
            // Connect line from hand to paddle
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, h - 30);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.3)';
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        // Draw Paddle (Drone)
        let py = h - 30;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00f3ff';
        ctx.fillStyle = '#00f3ff';
        
        ctx.beginPath();
        ctx.moveTo(x - width/2, py);
        ctx.lineTo(x + width/2, py);
        ctx.lineTo(x + width/2 - 10, py + 10);
        ctx.lineTo(x - width/2 + 10, py + 10);
        ctx.fill();

        // Engine Light
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(x, py + 5, 5, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    function drawBall(x, y, radius) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI*2);
        ctx.fillStyle = '#ff0055';
        ctx.fill();
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0055';
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // --- GAME LOGIC ---

    function updatePhysics(aspectRatio) {
        if (!gameActive) return;

        // Move Ball
        ball.x += ball.vx;
        ball.y += ball.vy * aspectRatio; // Adjust for screen shape

        // Wall Collisions
        if (ball.x <= 0 || ball.x >= 1) ball.vx *= -1;
        if (ball.y <= 0) ball.vy *= -1;

        // Paddle Collision
        // Paddle Y is at ~0.95 (bottom)
        if (ball.y > 0.9 && ball.y < 0.96) {
            let paddleWidth = 0.15; // 15% of screen
            if (ball.x > paddleX - paddleWidth/2 && ball.x < paddleX + paddleWidth/2) {
                ball.vy = -Math.abs(ball.vy * 1.05); // Bounce Up
                score++;
                scoreEl.innerText = score;
            }
        }

        // Miss
        if (ball.y > 1.0) {
            score = 0;
            scoreEl.innerText = 0;
            ball.y = 0.1;
            ball.vy = 0.005;
            ball.vx = 0.005;
        }
    }

    // --- AI TRACKING ---

    function onResults(results) {
        if (!gameActive) {
            gameActive = true;
            loadingScreen.style.display = 'none';
        }

        // Canvas Setup
        let w = canvasElement.width;
        let h = canvasElement.height;
        let aspectRatio = w / h;

        ctx.save();
        ctx.clearRect(0, 0, w, h);
        
        // Draw Darkened Camera Feed
        ctx.filter = 'grayscale(100%) brightness(30%)';
        ctx.drawImage(results.image, 0, 0, w, h);
        ctx.filter = 'none';

        // Check for Hands
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            handDetected = true;
            statusEl.innerText = "STATUS: TARGET LOCKED";
            statusEl.className = "status-locked";

            // Track CENTER of hand (Landmark 9) for stability
            const hand = results.multiHandLandmarks[0];
            const handCenter = hand[9]; 
            
            // Smooth movement
            paddleX += (handCenter.x - paddleX) * 0.3; 
            
            // Draw Hand Skeleton (Visual Feedback)
            drawConnectors(ctx, hand, HAND_CONNECTIONS, {color: '#00ff00', lineWidth: 1});

        } else {
            handDetected = false;
            statusEl.innerText = "STATUS: SEARCHING...";
            statusEl.className = "status-searching";
        }

        // Update & Draw Game
        updatePhysics(aspectRatio);
        
        let ballPx = ball.x * w;
        let ballPy = ball.y * h;
        let paddlePx = paddleX * w;

        drawDrone(paddlePx, results.multiHandLandmarks && results.multiHandLandmarks.length > 0 ? results.multiHandLandmarks[0][9].y * h : h-50, w, h);
        drawBall(ballPx, ballPy, 10);

        ctx.restore();
    }

    // Initialize
    function resize() {
        canvasElement.width = canvasElement.parentElement.clientWidth;
        canvasElement.height = canvasElement.parentElement.clientHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1, 
        modelComplexity: 1, 
        minDetectionConfidence: 0.5, 
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 1280, height: 720
    });
    camera.start();

</script>
</body>
</html>
